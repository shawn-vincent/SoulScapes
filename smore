#!/usr/bin/env node
/**
 * Robust smore with Command Line, Highlighted Log Context, and Copy Screen Feature
 * 
 * A log file viewer for append-only log files (with possible truncation/rotation).
 * 
 * Features:
 *  - Displays every file line exactly once (each line carries an absolute offset).
 *  - Inserts a top marker at the beginning and a bottom marker when at EOF.
 *  - Renders a full screen of file lines (with horizontal scrolling and arrow indicators)
 *    in the content area (all but the bottom line).
 *  - Reserves the bottommost line as a command line:
 *      - When inactive, it shows a help message (including the filename and supported keys).
 *      - When activated (via "/" key), it accepts a command.
 *        Upon [enter] the executeCommand function is called with the typed command and
 *        a parsed version of the currently highlighted log line.
 *  - Supports navigation (up/down/pageup/pagedown/home/end/left/right).
 *  - Auto-refreshes when the file is appended to, or if it’s truncated/rotated.
 *  - Module resolution magic is re‑added.
 *  - Log line formatting is robust (omitting missing parts) with padded hours.
 *  - I/O errors are wrapped with contextual info and then propagate.
 *  - **New:** Pressing uppercase "C" copies the current screen contents to the system clipboard.
 */

const fs = require('fs');
const path = require('path');

// --- Module Path Magic ---
const additionalModulesPath = path.resolve(__dirname, 'soulscapes-server', 'node_modules');
module.paths.push(additionalModulesPath);

const sliceAnsiModule = require('slice-ansi');
const sliceAnsi = sliceAnsiModule.default || sliceAnsiModule;
const blessed = require('blessed');
const stringWidth = require('string-width').default;
const clipboardyModule = require('clipboardy');  // For copying to the clipboard
const clipboardy = clipboardyModule.default || clipboardyModule;
const { sdebug, slog, slogConfig, slogParseLine } = require('./shared/slogger.js');

// --- Configuration Constants ---
const CONFIG = {
    maxLineBuffer: 10000,
    readChunkSize: 65536, // 64KB
    refreshInterval: 100, // every 100ms
    initialLines: 100,    // number of lines to load per operation
    markers: {
        top: '<<< TOP OF FILE >>>',
        bottom: '<<< BOTTOM OF FILE >>>'
    }
};

// --- Logging Configuration ---
slogConfig({
    slog: [
        "warn",
        { type: "file", path: "logs/smore.log" }
    ]
});

// --- Simple Mutex for Concurrency Control ---
class Mutex {
    constructor() {
        this._locked = false;
        this._waiting = [];
    }
    lock() {
        return new Promise(resolve => {
            if (this._locked) {
                this._waiting.push(resolve);
            } else {
                this._locked = true;
                resolve();
            }
        });
    }
    unlock() {
        if (this._waiting.length > 0) {
            const nextResolve = this._waiting.shift();
            nextResolve();
        } else {
            this._locked = false;
        }
    }
}

// ======================================================================
// 1. FileReader: Handles I/O with robust error wrapping.
//    Returns line objects { text, offset }.
// ======================================================================
class FileReader {
    constructor(filePath) {
        this.filePath = filePath;
        this.fileHandle = null;
        this.fileSize = 0;
        this.currentOffset = 0; // pointer for forward reading
    }

    async open() {
        try {
            this.fileHandle = await fs.promises.open(this.filePath, 'r');
            const stats = await this.fileHandle.stat();
            this.fileSize = stats.size;
            this.currentOffset = 0;
        } catch (err) {
            throw new Error(`Error opening file "${this.filePath}"`, { cause: err });
        }
    }

    async readChunk(offset, size) {
        try {
            const buffer = Buffer.alloc(size);
            const { bytesRead } = await this.fileHandle.read(buffer, 0, size, offset);
            return { buffer: buffer.slice(0, bytesRead), bytesRead };
        } catch (err) {
            throw new Error(`Error reading chunk at offset ${offset} (size ${size})`, { cause: err });
        }
    }

    async readForward(minLines) {
        const { StringDecoder } = require('string_decoder');
        const decoder = new StringDecoder('utf8');
        let lines = [];
        let offset = this.currentOffset;
        let leftover = '';
        try {
            while (lines.length < minLines && offset < this.fileSize) {
                const toRead = Math.min(CONFIG.readChunkSize, this.fileSize - offset);
                const { buffer, bytesRead } = await this.readChunk(offset, toRead);
                if (bytesRead <= 0) break;
                let chunkStr = leftover + decoder.write(buffer);
                leftover = '';
                let startIdx = 0, idx;
                while ((idx = chunkStr.indexOf('\n', startIdx)) !== -1) {
                    lines.push({ text: chunkStr.substring(startIdx, idx), offset: offset + startIdx });
                    startIdx = idx + 1;
                }
                leftover = (startIdx < chunkStr.length) ? chunkStr.substring(startIdx) : '';
                offset += bytesRead;
            }
            const remaining = decoder.end();
            if (remaining) leftover += remaining;
            if (leftover.length > 0) {
                lines.push({ text: leftover, offset: offset - leftover.length });
            }
            this.currentOffset = offset;
            return lines;
        } catch (err) {
            throw new Error(`Error reading forward from offset ${this.currentOffset}`, { cause: err });
        }
    }

    async readBackward(endOffset, minLines) {
        const { StringDecoder } = require('string_decoder');
        const decoder = new StringDecoder('utf8');
        let lines = [];
        let offset = endOffset;
        let leftover = '';
        try {
            while (lines.length < minLines && offset > 0) {
                const toRead = Math.min(CONFIG.readChunkSize, offset);
                const readStart = offset - toRead;
                const { buffer, bytesRead } = await this.readChunk(readStart, toRead);
                if (bytesRead <= 0) break;
                let chunkStr = decoder.write(buffer);
                chunkStr = chunkStr + leftover;
                leftover = '';
                let indices = [];
                let idx = chunkStr.lastIndexOf('\n');
                while (idx !== -1) {
                    indices.push(idx);
                    idx = chunkStr.lastIndexOf('\n', idx - 1);
                }
                let chunkLines = [];
                let start = 0;
                if (indices.length > 0) {
                    for (let i = indices.length - 1; i >= 0; i--) {
                        let pos = indices[i];
                        let lineText = chunkStr.substring(start, pos);
                        chunkLines.push({ text: lineText, offset: readStart + start });
                        start = pos + 1;
                    }
                    leftover = chunkStr.substring(start);
                } else {
                    leftover = chunkStr;
                }
                lines = chunkLines.concat(lines);
                offset = readStart;
            }
            if (offset === 0 && leftover.length > 0) {
                lines.unshift({ text: leftover, offset: 0 });
            }
            return lines;
        } catch (err) {
            throw new Error(`Error reading backward from offset ${endOffset}`, { cause: err });
        }
    }
}

// ======================================================================
// 2. BufferManager: Maintains the loaded log lines with their absolute offsets.
//    Uses a mutex to serialize asynchronous updates.
// ======================================================================
class BufferManager {
    constructor(fileReader) {
        this.fileReader = fileReader;
        this.lines = []; // Sorted by offset (ascending)
        this.topIndex = 0; // Index into this.lines for the top of the screen.
        // highlightIndex: -1 = top marker; 0..(lines.length - 1) = file lines; lines.length = bottom marker.
        this.highlightIndex = 0;
        this.mutex = new Mutex();
    }

    async fillForward(minLines = CONFIG.initialLines) {
        await this.mutex.lock();
        try {
            const newLines = await this.fileReader.readForward(minLines);
            if (newLines.length > 0) {
                if (this.lines.length > 0) {
                    const lastOffset = this.lines[this.lines.length - 1].offset;
                    const filtered = newLines.filter(line => line.offset > lastOffset);
                    this.lines.push(...filtered);
                } else {
                    this.lines.push(...newLines);
                }
            }
            this.pruneBuffer();
        } finally {
            this.mutex.unlock();
        }
    }

    async fillBackward(minLines = CONFIG.initialLines) {
        await this.mutex.lock();
        try {
            if (this.lines.length === 0) {
                const stats = await this.fileReader.fileHandle.stat();
                const newLines = await this.fileReader.readBackward(stats.size, minLines);
                this.lines = newLines;
                this.fileReader.currentOffset = stats.size;
            } else {
                const firstOffset = this.lines[0].offset;
                if (firstOffset > 0) {
                    const newLines = await this.fileReader.readBackward(firstOffset, minLines);
                    if (newLines.length > 0) {
                        const lastNew = newLines[newLines.length - 1].offset;
                        if (lastNew < firstOffset) {
                            this.lines = newLines.concat(this.lines);
                        }
                    }
                }
            }
            this.pruneBuffer();
        } finally {
            this.mutex.unlock();
        }
    }

    pruneBuffer() {
        if (this.lines.length <= CONFIG.maxLineBuffer) return;
        const excess = this.lines.length - CONFIG.maxLineBuffer;
        if (this.highlightIndex >= Math.floor(this.lines.length / 2)) {
            this.lines.splice(0, excess);
            this.topIndex = Math.max(0, this.topIndex - excess);
            this.highlightIndex = Math.max(0, this.highlightIndex - excess);
        } else {
            this.lines.splice(this.lines.length - excess, excess);
        }
    }

    canSelectTopMarker() {
        return this.topIndex === 0;
    }

    canSelectBottomMarker() {
        return this.fileReader.currentOffset >= this.fileReader.fileSize;
    }

    getHighlightBounds() {
        const minIndex = this.canSelectTopMarker() ? -1 : 0;
        const maxIndex = this.canSelectBottomMarker() ? this.lines.length : this.lines.length - 1;
        return { minIndex, maxIndex };
    }
}

// ======================================================================
// Helper: Slices a string based on visible columns (using sliceAnsi and stringWidth)
// ======================================================================
// Helper: Slices a string based on visible columns and overlays arrows for horizontal scrolling.
function formatScrollText(text, scrollLeft, width) {
  // Get the visible portion of the text.
  let visible = sliceAnsi(text, scrollLeft, scrollLeft + width);
  let currentWidth = stringWidth(visible);
  if (currentWidth < width) {
    visible += ' '.repeat(width - currentWidth);
  }
  
  // If we've scrolled to the right, overlay a left arrow on the first column.
  if (scrollLeft > 0) {
    // Replace the first visible column with a left arrow without changing the total width.
    let rest = sliceAnsi(visible, 1);
    visible = '←' + rest;
  }
  
  // If there is more text to the right than fits, overlay a right arrow on the last column.
  if (stringWidth(text) > scrollLeft + width) {
    let prefix = sliceAnsi(visible, 0, width - 1);
    visible = prefix + '→';
  }
  
  return visible;
}
// ======================================================================
// 3. View: Renders the file content and command line, and handles navigation.
//    The screen is split into two areas:
//      - contentBox: occupies all but the bottom line.
//      - cmdBox: occupies the bottommost line.
//    Also handles command mode and includes new key handlers.
// ======================================================================
class View {
    constructor(buffer, filePath) {
        this.buffer = buffer;
        this.filePath = filePath;
        this.scrollLeft = 0;
        this.cmdActive = false;
        this.screen = blessed.screen({
            smartCSR: true,
            fullUnicode: true,
            title: 'smore'
        });
        this.contentBox = blessed.box({
            top: 0,
            left: 0,
            width: '100%',
            height: '100%-1',
            tags: true,
            wrap: false,

            style: { fg: 'white', bg: 'black' }
        });
        this.cmdBox = blessed.textbox({
            bottom: 0,
            left: 0,
            width: '100%',
            height: 1,
            inputOnFocus: true,
            style: { fg: 'yellow', bg: 'blue' }
        });
        this.screen.append(this.contentBox);
        this.screen.append(this.cmdBox);
        this.setCmdHelp();
        this.setupKeyHandlers();
    }

    setCmdHelp() {
        const helpText = `[q:quit, /:command, c:copy screen] ${this.filePath}`;
        const width = this.screen.width;
        const truncated = helpText.length > width ? helpText.substring(0, width) : helpText;
        this.cmdBox.setContent(truncated);
    }

    buildMarkerText(type, width) {
        const text = CONFIG.markers[type];
        const visibleLength = stringWidth(text);
        const leftPad = Math.max(0, Math.floor((width - visibleLength) / 2));
        const rightPad = width - leftPad - visibleLength;
        return ' '.repeat(leftPad) +
            '{bold}{cyan-fg}' + text + '{/cyan-fg}{/bold}' +
            ' '.repeat(rightPad);
    }

    // Format a Date object with padded hours.
    formatTime(date, includeSeconds) {
        let hours = date.getHours() % 12 || 12;
        let hoursStr = hours < 10 ? ' ' + hours : '' + hours;
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        const ampm = date.getHours() >= 12 ? 'pm' : 'am';
        const minStr = minutes < 10 ? '0' + minutes : minutes;
        let timeStr = hoursStr + ':' + minStr;
        if (includeSeconds) {
            const secStr = seconds < 10 ? '0' + seconds : seconds;
            timeStr += ':' + secStr;
        }
        return timeStr + ampm;
    }

    formatConciseDate(timestamp) {
        const dateObj = new Date(timestamp);
        if (isNaN(dateObj)) return '';
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const target = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate());
        const diffDays = Math.floor((today - target) / (1000 * 60 * 60 * 24));
        if (diffDays === 0) return this.formatTime(dateObj, true);
        else if (diffDays > 0 && diffDays < 7) return '-' + diffDays + 'd ' + this.formatTime(dateObj, false);
        else {
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            return monthNames[dateObj.getMonth()] + ' ' + dateObj.getDate() + ' ' + this.formatTime(dateObj, false);
        }
    }

    formatLogLine(rawText) {
        const parsed = slogParseLine(rawText);
        let parts = [];
        if (parsed.timestamp) {
            const concise = this.formatConciseDate(parsed.timestamp);
            if (concise) parts.push(`[${concise}]`);
        }
        if (parsed.component) {
            if (parsed.component.startsWith('_remote')) {
                const match = parsed.component.match(/_remote\[(.*?)\]/);
                parts.push(match ? '🌐[' + match[1] + ']' : '🌐');
            } else {
                parts.push('.' + parsed.component);
            }
        }
        if (parsed.level && parsed.level !== 'log') {
            parts.push(parsed.level + ':');
        }
        if (parsed.message) {
            parts.push(parsed.message);
        }
        return parts.join(' ').trim();
    }


async renderContent() {
  const height = this.contentBox.height;
  const width = this.screen.width;
  
  // Determine if a top marker should be shown.
  const showTopMarker = (this.buffer.topIndex === 0 && this.buffer.highlightIndex !== this.buffer.lines.length);
  
  // Calculate available rows after reserving space for the top marker (if any).
  const availableRows = height - (showTopMarker ? 1 : 0);
  
  // The view is anchored at the bottom if topIndex is at its maximum value.
  const anchoredBottom = this.buffer.topIndex === Math.max(0, this.buffer.lines.length - availableRows)+1 /* +1 for bottom marker row */;
  
  // Show bottom marker only if at EOF and the view is exactly anchored at the bottom.
  const showBottomMarker = this.buffer.canSelectBottomMarker() && anchoredBottom;
  
  // Reserve file area rows: subtract one row for the bottom marker if it's shown.
  const fileArea = availableRows - (showBottomMarker ? 1 : 0);

  let rows = [];
  if (showTopMarker) {
    rows.push(this.buildMarkerText('top', width));
  }
  
  // Get the file lines that fit in the available file area.
  const visibleLines = this.buffer.lines.slice(this.buffer.topIndex, this.buffer.topIndex + fileArea);
  
  let fileRows = visibleLines.map(lineObj => {
    const rawText = lineObj.text || '';
    const fullText = this.formatLogLine(rawText);
    return formatScrollText(fullText, this.scrollLeft, width);
  });
  
  // If there are fewer file lines than fileArea, pad with blank lines.
  while (fileRows.length < fileArea) {
    fileRows.push(' '.repeat(width));
  }
  
  rows = rows.concat(fileRows);
  if (showBottomMarker) {
    rows.push(this.buildMarkerText('bottom', width));
  }
  
  // Apply highlight styling.
  const highlightRow = this.calculateHighlightRow(rows.length);
  if (highlightRow >= 0 && highlightRow < rows.length) {
    rows[highlightRow] = `{inverse}${rows[highlightRow]}{/inverse}`;
  }
  
  this.contentBox.setContent(rows.join('\n'));
}
    
    // Render full screen: content and command areas.
    async render() {
        await this.renderContent();
        if (!this.cmdActive) {
            this.setCmdHelp();
        }
        this.screen.render();
    }

    setupKeyHandlers() {
        this.screen.key(['escape', 'q', 'C-c'], () => process.exit(0));
        this.screen.key(['up'], async () => { if (!this.cmdActive) await this.moveHighlight(-1); });
        this.screen.key(['down'], async () => { if (!this.cmdActive) await this.moveHighlight(1); });
        this.screen.key(['pageup'], async () => { if (!this.cmdActive) await this.moveHighlight(-this.contentBox.height); });
        this.screen.key(['pagedown'], async () => { if (!this.cmdActive) await this.moveHighlight(this.contentBox.height); });
        this.screen.key(['home'], async () => { if (!this.cmdActive) {
	    this.screen.realloc();
	    await this.jumpToTop();
	}});
	this.screen.key(['end'], async () => { if (!this.cmdActive) {
	    this.screen.realloc();
	    await this.jumpToBottom();
	}});
        this.screen.key(['left'], () => { if (!this.cmdActive) {
	    this.screen.realloc();
	    this.scroll(-5);
	}});
	this.screen.key(['right'], () => { if (!this.cmdActive) {
	    this.screen.realloc();
	    this.scroll(5);
	}});
        this.screen.key(['/'], () => { if (!this.cmdActive) this.enterCommandMode(); });
        // New key: Capital C to copy screen contents.
        this.screen.key(['c'], () => {
            slog("copying screen to clipboard");
            if (!this.cmdActive) this.copyScreen();
        });
        // Refresh key: Ctrl-L
        this.screen.key(['C-l'], async () => {
            slog("refreshing screen");
            this.screen.realloc();
            await this.render();
        });
        this.screen.on('resize', () => { this.render(); });
    }

    calculateHighlightRow(totalRows) {
        const hasTopMarker = (this.buffer.canSelectTopMarker() && this.buffer.topIndex === 0);
        const hasBottomMarker = this.buffer.canSelectBottomMarker();
        const fileArea = totalRows - (hasTopMarker ? 1 : 0) - (hasBottomMarker ? 1 : 0);
        
        // Determine how many file lines are available.
        const availableFileLines = this.buffer.lines.length - this.buffer.topIndex;
        const topPadding = availableFileLines < fileArea ? fileArea - availableFileLines : 0;
        
        if (this.buffer.highlightIndex === -1) return hasTopMarker ? 0 : 0;
        if (this.buffer.highlightIndex === this.buffer.lines.length) return totalRows - 1;
        
        const relativeRow = this.buffer.highlightIndex - this.buffer.topIndex;
        let highlightRow = (hasTopMarker ? 1 : 0) + topPadding + relativeRow;
        if (highlightRow >= totalRows) highlightRow = totalRows - 1;
        return highlightRow;
    }
    
    async moveHighlight(delta) {
        const { minIndex, maxIndex } = this.buffer.getHighlightBounds();
        let newIndex = this.buffer.highlightIndex + delta;
        newIndex = Math.max(minIndex, Math.min(newIndex, maxIndex));
        this.buffer.highlightIndex = newIndex;
        if (delta < 0 && this.buffer.highlightIndex === minIndex && this.buffer.topIndex === 0) {
            await this.buffer.fillBackward();
        }
        if (delta > 0 && this.buffer.highlightIndex === maxIndex && !this.buffer.canSelectBottomMarker()) {
            await this.buffer.fillForward();
        }

	
        await this.adjustView();
	this.screen.realloc();
	
        await this.render();
    }

    async adjustView() {
	const height = this.contentBox.height;
	// Determine if a top marker should be shown.
	const useTopMarker = (this.buffer.topIndex === 0 && this.buffer.highlightIndex !== this.buffer.lines.length);
	const markerOffset = useTopMarker ? 1 : 0;
	const fileArea = height - markerOffset - (this.buffer.canSelectBottomMarker() ? 1 : 0);

	// Special handling for the top marker (highlightIndex === -1)
	if (this.buffer.highlightIndex === -1) {
            this.buffer.topIndex = 0;
	} else if (this.buffer.highlightIndex === this.buffer.lines.length) {
            // When the bottom marker is selected, adjust view to show the last file lines.
            this.buffer.topIndex = Math.max(0, this.buffer.lines.length - fileArea);
	} else {
            // Normal case: Adjust view if the highlighted line is outside the current window.
            if (this.buffer.highlightIndex < this.buffer.topIndex) {
		this.buffer.topIndex = this.buffer.highlightIndex;
            } else if (this.buffer.highlightIndex >= this.buffer.topIndex + fileArea) {
		this.buffer.topIndex = this.buffer.highlightIndex - fileArea + 1;
            }
	}
    }

    scroll(delta) {
        this.scrollLeft = Math.max(0, this.scrollLeft + delta);
        this.render();
    }

 async jumpToTop() {
    this.buffer.lines = [];
    this.buffer.topIndex = 0;
    this.buffer.highlightIndex = -1;
    // Reset the file reading pointer to the beginning of the file.
    this.buffer.fileReader.currentOffset = 0;
    await this.buffer.fillForward(this.contentBox.height);
    await this.render();
 }
    
    async jumpToBottom() {
        this.buffer.lines = [];
        this.buffer.topIndex = 0;
        await this.buffer.fillBackward(this.contentBox.height * 2);
        this.buffer.highlightIndex = this.buffer.lines.length;
        const stats = await this.buffer.fileReader.fileHandle.stat();
        this.buffer.fileReader.fileSize = stats.size;
        this.buffer.fileReader.currentOffset = stats.size;
        await this.adjustView();
        await this.render();
    }

    // Enter command mode: clear cmdBox and accept input.
    enterCommandMode() {
        this.cmdActive = true;
        this.cmdBox.clearValue();
        this.cmdBox.focus();
        this.cmdBox.readInput(async (err, value) => {
            if (err) {
                this.cmdActive = false;
                this.setCmdHelp();
		
		this.screen.realloc();
                this.screen.render();
                return;
            }
            // Get the currently highlighted log line, if any.
            let parsedLog = null;
            if (this.buffer.highlightIndex >= 0 && this.buffer.highlightIndex < this.buffer.lines.length) {
                let rawText = this.buffer.lines[this.buffer.highlightIndex].text;
                parsedLog = slogParseLine(rawText);
            }
            const output = await this.executeCommand(value, parsedLog);
            this.cmdBox.setContent(output);
            this.cmdActive = false;
            this.screen.focusPop();
            this.render();
        });
    }

    // Execute the command with command text and parsed log context.
    async executeCommand(commandText, parsedLog) {
        return `Command executed: ${commandText}\nParsed log: ${JSON.stringify(parsedLog)}`;
    }

    // New: Copy current screen contents to the system clipboard.
    async copyScreen() {
        // Combine the contentBox and cmdBox contents.
        const content = this.contentBox.getContent();
        const cmd = this.cmdBox.getContent();
        const fullScreenText = content.split('\n').concat([cmd]).join('\n');
        await clipboardy.writeSync("====== smore screenshot ======\n" + fullScreenText);
        // Display a temporary message in the command line.
        this.cmdBox.setContent("Screen copied to clipboard");
        this.screen.render();
        setTimeout(() => {
            if (!this.cmdActive) {
                this.setCmdHelp();
		this.screen.realloc();
                this.screen.render();
            }
        }, 2000);
    }
}

// ======================================================================
// 4. Main / Auto-Refresh: Setup, initial load, and file-change monitoring.
// ======================================================================
async function main() {
    if (process.argv.length < 3) {
        console.error('Usage: smore <filename>');
        process.exit(1);
    }
    try {
        const filePath = process.argv[2];
        const fileReader = new FileReader(filePath);
        await fileReader.open();

        const buffer = new BufferManager(fileReader);
        const view = new View(buffer, filePath);

        // Initial load: read backward so that the bottom of the file is visible.
        await buffer.fillBackward(view.contentBox.height * 2);
        buffer.highlightIndex = buffer.lines.length; // select bottom marker

        // Update forward pointer.
        const stats = await fileReader.fileHandle.stat();
        fileReader.fileSize = stats.size;
        fileReader.currentOffset = stats.size;
        await view.adjustView();
        await view.render();

        // Monitor file changes.
        setInterval(async () => {
            try {
                const stats = await fileReader.fileHandle.stat();
                if (stats.size < fileReader.fileSize) {
                    fileReader.fileSize = stats.size;
                    fileReader.currentOffset = 0;
                    buffer.lines = [];
                    buffer.topIndex = 0;
                    buffer.highlightIndex = -1;
                    await buffer.fillForward(view.contentBox.height);
                } else if (stats.size > fileReader.fileSize) {
                    fileReader.fileSize = stats.size;
                    if (buffer.highlightIndex === buffer.lines.length) {
                        await buffer.fillForward();
                        buffer.highlightIndex = buffer.lines.length;
                        await view.adjustView();
                    }
                }
		view.screen.realloc();

                await view.render();
            } catch (err) {
                slog('Error checking file size:', err);
            }
        }, CONFIG.refreshInterval);

    } catch (err) {
        slog('Error:', err);
        process.exit(1);
    }
}

main();
