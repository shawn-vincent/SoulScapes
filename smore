#!/usr/bin/env node
/*
  smore — a "less"-like pager for large log files (no stdin).
  
  Features:
   - Up/Down arrows: move highlight line-by-line (markers are selectable)
   - PgUp/PgDn: page up/down
   - Home: jump to top marker
   - End: jump to bottom marker
   - Left/Right: horizontal scroll (applies only to file lines)
   - 'q' / Esc / Ctrl-C: quit
   - Synthetic markers for top and bottom of file
   - Auto-refresh if file grows and you're at the bottom
  
  New in this version:
   - The <TOP> and <BOTTOM> markers are centered on screen (ignoring horizontal scroll)
   - When a marker is highlighted, the inverse (highlight) formatting covers the entire line.
   - The reachedEOF flag is now updated whenever the file grows so that the bottom marker only shows when you are truly at the end.
*/

const fs = require('fs');
const path = require('path');


// Add the soulscapes-server/node_modules directory to the module
// resolution paths.
const additionalModulesPath =
      path.resolve(__dirname, 'soulscapes-server', 'node_modules');
module.paths.push(additionalModulesPath);

const blessed = require('blessed');
const stringWidth = require('string-width').default;
const { sdebug, slogConfig, slog, slogParseLine } = require('./shared/slogger.js');

// Configuration constants
const CONFIG = {
    maxLineBuffer: 10000,
    readChunkSize: 65536, // 64KB
    refreshInterval: 100, // 0.1 second
    initialLines: 100,    // Default number of lines to load initially
    markers: {
	top: '<<< TOP OF FILE >>>',
	bottom: '<<< BOTTOM OF FILE >>>'
    }
};

// Configure logging
slogConfig({
    slog: [
	"warn",
	{
	    type: "file",
	    path: "logs/smore.log"
	}]
});

class FileReader {
    constructor(filePath) {
	this.filePath = filePath;
	this.fileHandle = null;
	this.fileSize = 0;
	this.reachedEOF = false;
	this.currentOffset = 0; // Track the last read position

    }

    async open() {
	this.fileHandle = await fs.promises.open(this.filePath, 'r');
	const stats = await this.fileHandle.stat();
	this.fileSize = stats.size;
	// currentOffset remains 0 until we start reading
    }

    async readChunk(offset, size) {
	const buffer = Buffer.alloc(size);
	const { bytesRead } = await this.fileHandle.read(buffer, 0, size, offset);
	return { buffer: buffer.slice(0, bytesRead), bytesRead };
    }

    async readForward(startOffset, minLines) {
	const { StringDecoder } = require('string_decoder');
	const decoder = new StringDecoder('utf8');
	let results = [];
	let offset = startOffset;
	let textBuffer = '';

	while (results.length < minLines && offset < this.fileSize) {
	    const toRead = Math.min(CONFIG.readChunkSize, this.fileSize - offset);
	    const { buffer, bytesRead } = await this.readChunk(offset, toRead);
	    
	    if (bytesRead <= 0) break;

	    let chunkStr = decoder.write(buffer);
	    chunkStr = textBuffer + chunkStr;
	    textBuffer = '';

	    let startIdx = 0;
	    let idx;
	    while ((idx = chunkStr.indexOf('\n', startIdx)) !== -1) {
		results.push({ text: chunkStr.substring(startIdx, idx) });
		startIdx = idx + 1;
	    }
	    
	    textBuffer = startIdx < chunkStr.length ? chunkStr.substring(startIdx) : '';
	    offset += bytesRead;
	}

	const remaining = decoder.end();
	if (remaining) textBuffer += remaining;
	
	if (textBuffer.length > 0) {
	    if (results.length > 0) {
		results[results.length - 1].text += textBuffer;
	    } else {
		results.push({ text: textBuffer });
	    }
	}

	this.reachedEOF = offset >= this.fileSize;
	this.currentOffset = offset;  // update the current offset after reading

	return results;
    }

    async readBackward(endOffset, minLines) {
	let results = [];
	let offset = endOffset;
	let leftover = '';

	while (results.length < minLines && offset > 0) {
	    const toRead = Math.min(CONFIG.readChunkSize, offset);
	    const readStart = offset - toRead;
	    const { buffer, bytesRead } = await this.readChunk(readStart, toRead);
	    
	    if (bytesRead <= 0) break;

	    const chunkStr = buffer.toString('utf8') + leftover;
	    leftover = '';

	    const lines = [];
	    let lastPos = chunkStr.length;
	    let idx;
	    
	    while ((idx = chunkStr.lastIndexOf('\n', lastPos - 1)) !== -1) {
		const lineStart = readStart + idx + 1;
		lines.push({ text: chunkStr.substring(idx + 1, lastPos),
			     start: lineStart });
 		lastPos = idx;
	    }
	    
	    if (lastPos > 0) leftover = chunkStr.substring(0, lastPos);
	    
	    lines.reverse();
	    results = [...lines, ...results];
	    offset = readStart;
	}

	if (offset === 0 && leftover.length > 0) {
	    results.unshift({ text: leftover });
	}

	// Remove trailing empty line to match forward-reading behavior
	if (results.length && results[results.length - 1].text === '') {
	    results.pop();
	}

	return results;
    }
}

class BufferManager {
    constructor(fileReader) {
	this.fileReader = fileReader;
	this.lines = [];
	this.topIndex = 0;
	// highlightIndex can now be:
	// -1 for top marker
	// 0 to lines.length-1 for file lines
	// lines.length for bottom marker (when at EOF)
	this.highlightIndex = 0;
    }

    async fillForward(minLines = 100) {
	if (!this.lines.length) {
	    const newLines = await this.fileReader.readForward(0, minLines);
	    this.lines.push(...newLines);
	    this.pruneBuffer();
	    return;
	}

	if (this.fileReader.currentOffset < this.fileReader.fileSize) {
            // Use the currentOffset, which marks the end of what
            // we've read so far
            const newLines =
		  await this.fileReader.readForward (this.fileReader
						     .currentOffset, minLines);
	    this.lines.push(...newLines);
	    this.pruneBuffer();
	}
    }

    async fillBackward(minLines = 100) {
	if (!this.lines.length) {
	    const stats = await this.fileReader.fileHandle.stat();
	    this.fileReader.fileSize = stats.size;
	    const newLines = await this.fileReader.readBackward(stats.size, minLines);
	    this.lines.push(...newLines);
	    this.pruneBuffer();
	    return;
	}

	const firstLine = this.lines[0];
	if (firstLine.start !== 0 && firstLine.start !== null) {
	    const newLines = await this.fileReader.readBackward(firstLine.start, minLines);
	    this.lines.unshift(...newLines);
	    this.pruneBuffer();
	}
    }

    pruneBuffer() {
	if (this.lines.length <= CONFIG.maxLineBuffer) return;

	const half = Math.floor(this.lines.length / 2);
	if (this.highlightIndex >= half) {
	    const removeCount = this.lines.length - CONFIG.maxLineBuffer;
	    this.lines.splice(0, removeCount);
	    this.highlightIndex -= removeCount;
	    this.topIndex = Math.max(0, this.topIndex - removeCount);
	} else {
	    const removeCount = this.lines.length - CONFIG.maxLineBuffer;
	    this.lines.splice(this.lines.length - removeCount, removeCount);
	}
    }

    canSelectTopMarker() {
	return this.topIndex === 0;
    }

    canSelectBottomMarker() {
	return this.fileReader.reachedEOF;
    }

    getHighlightBounds() {
	const minIndex = this.canSelectTopMarker() ? -1 : 0;
	const maxIndex = this.canSelectBottomMarker() ? this.lines.length : this.lines.length - 1;
	return { minIndex, maxIndex };
    }

}

class View {
    constructor(buffer) {
	this.buffer = buffer;
	this.scrollLeft = 0;
	this.screen = blessed.screen({
	    smartCSR: false,
	    fullUnicode: true,
	    title: 'smore'
	});

	this.box = blessed.box({
	    top: 0,
	    left: 0,
	    width: '100%',
	    height: '100%',
	    tags: true,
	    wrap: false,
	    noOverflow: true,
	    style: { fg: 'white', bg: 'black' }
	});

	this.screen.append(this.box);
	this.setupKeyHandlers();
    }

    formatConciseDate(dateObj) {
	const now = new Date();
	// Normalize today's date (strip time)
	const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
	const target = new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate());
	const diffMs = today - target; // positive if target is in the past
	const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

	// Helper to format time in 12-hour format.
	function formatTime(date, includeSeconds) {
	    let hours = date.getHours();
	    const minutes = date.getMinutes();
	    const seconds = date.getSeconds();
	    const ampm = hours >= 12 ? 'pm' : 'am';
	    hours = hours % 12;
	    if (hours === 0) hours = 12;
	    const minStr = minutes < 10 ? '0' + minutes : minutes;
	    let timeStr = hours + ':' + minStr;
	    if (includeSeconds) {
		const secStr = seconds < 10 ? '0' + seconds : seconds;
		timeStr += ':' + secStr;
	    }
	    timeStr += ampm;
	    return timeStr;
	}

	// Format based on how old the timestamp is.
	if (diffDays === 0) {
	    // For today: include seconds
	    return formatTime(dateObj, true);
	} else if (diffDays > 0 && diffDays < 7) {
	    // For up to 7 days ago: show the number of days and time (no seconds)
	    return '-' + diffDays + 'd ' + formatTime(dateObj, false);
	} else {
	    // For older dates: show abbreviated month, day, and time (no seconds)
	    const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
				"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
	    return monthNames[dateObj.getMonth()] + ' ' + dateObj.getDate() + ' ' + formatTime(dateObj, false);
	}
    }

    formatLogLine(rawText) {
	// Parse the raw log line.
	let parsed = slogParseLine(rawText);

	// Create a concise time: try parsing the timestamp and keep only the time portion.
	let conciseDate = parsed.timestamp;
	const dateObj = new Date(parsed.timestamp);
	if (!isNaN(dateObj)) {
            // Example: "14:35:07" (24-hour format)
            conciseDate = this.formatConciseDate(dateObj);
	}
	
	// Process the component: if it starts with "_remote", replace with an emoticon and keep client ID.
	let componentStr = '';
	if (parsed.component) {
            if (parsed.component.startsWith('_remote')) {
		// Look for a pattern like _remote[CLIENT 123]
		const match = parsed.component.match(/_remote\[(.*?)\]/);
		if (match) {
                    componentStr = '🌐[' + match[1] + ']';
		} else {
                    componentStr = '🌐';
		}
            } else {
		componentStr = '.' + parsed.component;
            }
	}
	
	// You can also show the log level (if desired)
	let levelStr = parsed.level == "log" ? "" : parsed.level+": ";
	
	// Reconstruct the line in your desired format.
	// For example: "[14:35:07] 🌐[CLIENT 123] LOG: The message"
	return `[${conciseDate}] ${componentStr} ${levelStr}${parsed.message}`.trim();
    }

    setupKeyHandlers() {
	this.screen.key(['escape', 'q', 'C-c'], () => process.exit(0));
	this.screen.key(['up'], () => this.moveHighlight(-1));
	this.screen.key(['down'], () => this.moveHighlight(1));
	this.screen.key(['pageup'], () => this.moveHighlight(-this.box.height));
	this.screen.key(['pagedown'], () => this.moveHighlight(this.box.height));
	this.screen.key(['home'], () => this.jumpToTop());
	this.screen.key(['end'], () => this.jumpToBottom());
	this.screen.key(['left'], () => this.scroll(-5));
	this.screen.key(['right'], () => this.scroll(5));
	this.screen.on('resize', () => this.render());
    }

    buildMarkerText(type, width) {
	const text = CONFIG.markers[type];
	const visibleLength = stringWidth(text);
	const leftPad = Math.floor((width - visibleLength) / 2);
	const rightPad = width - leftPad - visibleLength;
	return ' '.repeat(leftPad) + 
            '{bold}{cyan-fg}' + text + '{/cyan-fg}{/bold}' + 
            ' '.repeat(rightPad);
    }

    escapeForBlessed(str) {
	return str.replace(/{/g, '\\{').replace(/}/g, '\\}');
    }

     async render() {
        const rows = [];
        const pageHeight = this.box.height;
        const width = this.screen.width;

        // Add top marker if visible
        const showTopMarker = this.buffer.canSelectTopMarker() && this.buffer.topIndex === 0;
        if (showTopMarker) {
            rows.push({
                type: 'marker',
                marker: 'top',
                text: this.buildMarkerText('top', width)
            });
        }

        // Add file lines
        const availableHeight = pageHeight - (showTopMarker ? 1 : 0);
        const visibleLines = this.buffer.lines.slice(
            this.buffer.topIndex,
            this.buffer.topIndex + availableHeight
        );

         for (const line of visibleLines) {
	     let rawText = line.text || '';
	     // Parse and reformat the log line:
	     let text = this.formatLogLine(rawText);
	     
	     // Apply horizontal scrolling and pad to the screen width
	     if (this.scrollLeft < text.length) {
		 text = text.substring(this.scrollLeft);
	     } else {
		 text = '';
	     }
	     text = (text + ' '.repeat(width)).substring(0, width);
	     text = this.escapeForBlessed(text);
	     rows.push({ type: 'line', text });
	 }

        // Add bottom marker if at EOF
        if (this.buffer.canSelectBottomMarker() && rows.length < pageHeight) {
            rows.push({
                type: 'marker',
                marker: 'bottom',
                text: this.buildMarkerText('bottom', width)
            });
        }

        // Calculate which row should be highlighted
        let highlightRow = this.calculateHighlightRow();
        if (highlightRow >= 0 && highlightRow < rows.length) {
            rows[highlightRow].text = '{inverse}' + rows[highlightRow].text + '{/inverse}';
        }

        // Fill remaining space with empty lines
        while (rows.length < pageHeight) {
            rows.push({ type: 'empty', text: ' '.repeat(width) });
        }

        // Render to screen
        this.screen.realloc();
        this.box.setContent(rows.map(r => r.text).join('\n'));
        this.screen.render();
    }

    calculateHighlightRow() {
        if (this.buffer.highlightIndex === -1) {
            return this.buffer.canSelectTopMarker() && this.buffer.topIndex === 0 ? 0 : -1;
        }
        
        if (this.buffer.highlightIndex === this.buffer.lines.length) {
            const lastRow = this.box.height - 1;
            return this.buffer.canSelectBottomMarker() ? lastRow : -1;
        }

        if (this.buffer.highlightIndex < this.buffer.topIndex) {
            return -1;
        }

        const offset = (this.buffer.canSelectTopMarker() && this.buffer.topIndex === 0) ? 1 : 0;
        return offset + (this.buffer.highlightIndex - this.buffer.topIndex);
    }

    async moveHighlight(delta) {
        const { minIndex, maxIndex } = this.buffer.getHighlightBounds();
        const newIndex = this.buffer.highlightIndex + delta;
        
        // Clamp to valid range including markers
        this.buffer.highlightIndex = Math.max(minIndex, Math.min(newIndex, maxIndex));
        
        // If moving up at top, try to load more content
        if (delta < 0 && this.buffer.highlightIndex === 0 && this.buffer.topIndex === 0) {
            await this.buffer.fillBackward();
        }
        
        // If moving down near bottom, try to load more content
        if (delta > 0 && !this.buffer.fileReader.reachedEOF && 
            this.buffer.highlightIndex >= this.buffer.lines.length - this.box.height) {
            await this.buffer.fillForward();
        }

        // Ensure view follows highlight
        await this.adjustView();
        await this.render();
    }

    async adjustView() {
        const pageHeight = this.box.height;
        const markerOffset = this.buffer.canSelectTopMarker() && this.buffer.topIndex === 0 ? 1 : 0;
        
        // Handle top marker selection
        if (this.buffer.highlightIndex === -1) {
            this.buffer.topIndex = 0;
            return;
        }

        // Handle bottom marker selection
        if (this.buffer.highlightIndex === this.buffer.lines.length) {
            const visibleLines = pageHeight - (this.buffer.canSelectBottomMarker() ? 1 : 0);
            this.buffer.topIndex = Math.max(0, this.buffer.lines.length - visibleLines);
            return;
        }

        // Handle regular line selection
        if (this.buffer.highlightIndex < this.buffer.topIndex) {
            this.buffer.topIndex = this.buffer.highlightIndex;
        } else {
            const visibleLines = pageHeight - markerOffset - 
                  (this.buffer.canSelectBottomMarker() ? 1 : 0);
            if (this.buffer.highlightIndex >= this.buffer.topIndex + visibleLines) {
                this.buffer.topIndex = this.buffer.highlightIndex - visibleLines + 1;
            }
        }
    }
    
    scroll(delta) {
	this.scrollLeft = Math.max(0, this.scrollLeft + delta);
	this.render();
    }

    async jumpToTop() {
	this.buffer.lines = [];
	this.buffer.highlightIndex = -1; // Select top marker
	this.buffer.topIndex = 0;
	await this.buffer.fillForward(this.box.height);
	await this.render();
    }

    async jumpToBottom() {
	this.buffer.lines = [];
	this.buffer.topIndex = 0;
	await this.buffer.fillBackward(this.box.height * 2);
	this.buffer.highlightIndex = this.buffer.lines.length; // Select bottom marker
	await this.adjustView();
	await this.render();
    }
}

async function main() {
    if (process.argv.length < 3) {
        console.error('Usage: smore <filename>');
        process.exit(1);
    }

    try {
        // Create the file reader and open the file
        const fileReader = new FileReader(process.argv[2]);
        await fileReader.open();

        // Create the buffer manager
        const buffer = new BufferManager(fileReader);
        
        // Create the view (which creates the screen)
        const view = new View(buffer);
        
        // Initialize at the end of the file
        await buffer.fillBackward(view.box.height * 2);
        buffer.highlightIndex = buffer.lines.length; // Select bottom marker
	fileReader.currentOffset = fileReader.fileSize;
	await view.adjustView();
        await view.render();

        // Set up file growth check
        setInterval(async () => {
            try {
                const stats = await fileReader.fileHandle.stat();
                if (stats.size !== fileReader.fileSize) {
                    const wasAtBottom = buffer.highlightIndex === buffer.lines.length;
                    fileReader.fileSize = stats.size;
                    await buffer.fillForward();

                    
                    // If we were at bottom before, stay at bottom
                    if (wasAtBottom) {
                        buffer.highlightIndex = buffer.lines.length;
                        await view.adjustView();
                    }

                    
                    // Force screen refresh
                    await view.render();
                }
            } catch (err) {
                serror('Error checking file size:', err);
            }
        }, CONFIG.refreshInterval);

    } catch (err) {
        serror('Error:', err);
        process.exit(1);
    }
}

main();

//slog("parsed line", slogParseLine("[Feb 11 '25 23:13:47.751 EST] ._remote[CLIENT ::1] ✅ Connected to server"));
