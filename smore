#!/usr/bin/env node

const fs = require('fs');
const path = require('path');


// Add the soulscapes-server/node_modules directory to the module
// resolution paths.
const additionalModulesPath =
      path.resolve(__dirname, 'soulscapes-server', 'node_modules');
module.paths.push(additionalModulesPath);

const blessed = require('blessed');
const stringWidth = require('string-width').default;
const { sdebug, slogConfig } = require('./shared/slogger.js');

// Configuration constants
const CONFIG = {
    maxLineBuffer: 10000,
    readChunkSize: 65536, // 64KB
    refreshInterval: 1000, // 1 second
    initialLines: 100,    // Default number of lines to load initially
    markers: {
	top: '<<< TOP OF FILE >>>',
	bottom: '<<< BOTTOM OF FILE >>>'
    }
};

// Configure logging
slogConfig({
    slog: {
	type: "file",
	path: "logs/smore.log"
    }
});

class FileReader {
    constructor(filePath) {
	this.filePath = filePath;
	this.fileHandle = null;
	this.fileSize = 0;
	this.reachedEOF = false;
    }

    async open() {
	this.fileHandle = await fs.promises.open(this.filePath, 'r');
	const stats = await this.fileHandle.stat();
	this.fileSize = stats.size;
    }

    async readChunk(offset, size) {
	const buffer = Buffer.alloc(size);
	const { bytesRead } = await this.fileHandle.read(buffer, 0, size, offset);
	return { buffer: buffer.slice(0, bytesRead), bytesRead };
    }

    async readForward(startOffset, minLines) {
	const { StringDecoder } = require('string_decoder');
	const decoder = new StringDecoder('utf8');
	let results = [];
	let offset = startOffset;
	let textBuffer = '';

	while (results.length < minLines && offset < this.fileSize) {
	    const toRead = Math.min(CONFIG.readChunkSize, this.fileSize - offset);
	    const { buffer, bytesRead } = await this.readChunk(offset, toRead);
	    
	    if (bytesRead <= 0) break;

	    let chunkStr = decoder.write(buffer);
	    chunkStr = textBuffer + chunkStr;
	    textBuffer = '';

	    let startIdx = 0;
	    let idx;
	    while ((idx = chunkStr.indexOf('\n', startIdx)) !== -1) {
		results.push({ text: chunkStr.substring(startIdx, idx) });
		startIdx = idx + 1;
	    }
	    
	    textBuffer = startIdx < chunkStr.length ? chunkStr.substring(startIdx) : '';
	    offset += bytesRead;
	}

	const remaining = decoder.end();
	if (remaining) textBuffer += remaining;
	
	if (textBuffer.length > 0) {
	    if (results.length > 0) {
		results[results.length - 1].text += textBuffer;
	    } else {
		results.push({ text: textBuffer });
	    }
	}

	this.reachedEOF = offset >= this.fileSize;
	return results;
    }

    async readBackward(endOffset, minLines) {
	let results = [];
	let offset = endOffset;
	let leftover = '';

	while (results.length < minLines && offset > 0) {
	    const toRead = Math.min(CONFIG.readChunkSize, offset);
	    const readStart = offset - toRead;
	    const { buffer, bytesRead } = await this.readChunk(readStart, toRead);
	    
	    if (bytesRead <= 0) break;

	    const chunkStr = buffer.toString('utf8') + leftover;
	    leftover = '';

	    const lines = [];
	    let lastPos = chunkStr.length;
	    let idx;
	    
	    while ((idx = chunkStr.lastIndexOf('\n', lastPos - 1)) !== -1) {
		lines.push({ text: chunkStr.substring(idx + 1, lastPos) });
		lastPos = idx;
	    }
	    
	    if (lastPos > 0) leftover = chunkStr.substring(0, lastPos);
	    
	    lines.reverse();
	    results = [...lines, ...results];
	    offset = readStart;
	}

	if (offset === 0 && leftover.length > 0) {
	    results.unshift({ text: leftover });
	}

	// Remove trailing empty line to match forward-reading behavior
	if (results.length && results[results.length - 1].text === '') {
	    results.pop();
	}

	return results;
    }
}

class BufferManager {
    constructor(fileReader) {
	this.fileReader = fileReader;
	this.lines = [];
	this.topIndex = 0;
	// highlightIndex can now be:
	// -1 for top marker
	// 0 to lines.length-1 for file lines
	// lines.length for bottom marker (when at EOF)
	this.highlightIndex = 0;
    }

    async fillForward(minLines = 100) {
	if (!this.lines.length) {
	    const newLines = await this.fileReader.readForward(0, minLines);
	    this.lines.push(...newLines);
	    this.pruneBuffer();
	    return;
	}

	if (!this.fileReader.reachedEOF) {
	    const newLines = await this.fileReader.readForward(this.fileReader.fileSize, minLines);
	    this.lines.push(...newLines);
	    this.pruneBuffer();
	}
    }

    async fillBackward(minLines = 100) {
	if (!this.lines.length) {
	    const stats = await this.fileReader.fileHandle.stat();
	    this.fileReader.fileSize = stats.size;
	    const newLines = await this.fileReader.readBackward(stats.size, minLines);
	    this.lines.push(...newLines);
	    this.pruneBuffer();
	    return;
	}

	const firstLine = this.lines[0];
	if (firstLine.start !== 0 && firstLine.start !== null) {
	    const newLines = await this.fileReader.readBackward(firstLine.start, minLines);
	    this.lines.unshift(...newLines);
	    this.pruneBuffer();
	}
    }

    pruneBuffer() {
	if (this.lines.length <= CONFIG.maxLineBuffer) return;

	const half = Math.floor(this.lines.length / 2);
	if (this.highlightIndex >= half) {
	    const removeCount = this.lines.length - CONFIG.maxLineBuffer;
	    this.lines.splice(0, removeCount);
	    this.highlightIndex -= removeCount;
	    this.topIndex = Math.max(0, this.topIndex - removeCount);
	} else {
	    const removeCount = this.lines.length - CONFIG.maxLineBuffer;
	    this.lines.splice(this.lines.length - removeCount, removeCount);
	}
    }

    canSelectTopMarker() {
	return this.topIndex === 0;
    }

    canSelectBottomMarker() {
	return this.fileReader.reachedEOF;
    }

    getHighlightBounds() {
	const minIndex = this.canSelectTopMarker() ? -1 : 0;
	const maxIndex = this.canSelectBottomMarker() ? this.lines.length : this.lines.length - 1;
	return { minIndex, maxIndex };
    }

}

class View {
    constructor(buffer) {
	this.buffer = buffer;
	this.scrollLeft = 0;
	this.screen = blessed.screen({
	    smartCSR: false,
	    fullUnicode: true,
	    title: 'smore'
	});

	this.box = blessed.box({
	    top: 0,
	    left: 0,
	    width: '100%',
	    height: '100%',
	    tags: true,
	    wrap: false,
	    noOverflow: true,
	    style: { fg: 'white', bg: 'black' }
	});

	this.screen.append(this.box);
	this.setupKeyHandlers();
    }

    setupKeyHandlers() {
	this.screen.key(['escape', 'q', 'C-c'], () => process.exit(0));
	this.screen.key(['up'], () => this.moveHighlight(-1));
	this.screen.key(['down'], () => this.moveHighlight(1));
	this.screen.key(['pageup'], () => this.moveHighlight(-this.box.height));
	this.screen.key(['pagedown'], () => this.moveHighlight(this.box.height));
	this.screen.key(['home'], () => this.jumpToTop());
	this.screen.key(['end'], () => this.jumpToBottom());
	this.screen.key(['left'], () => this.scroll(-5));
	this.screen.key(['right'], () => this.scroll(5));
	this.screen.on('resize', () => this.render());
    }

    buildMarkerText(type, width) {
	const text = CONFIG.markers[type];
	const visibleLength = stringWidth(text);
	const leftPad = Math.floor((width - visibleLength) / 2);
	const rightPad = width - leftPad - visibleLength;
	return ' '.repeat(leftPad) + 
            '{bold}{cyan-fg}' + text + '{/cyan-fg}{/bold}' + 
            ' '.repeat(rightPad);
    }

    escapeForBlessed(str) {
	return str.replace(/{/g, '\\{').replace(/}/g, '\\}');
    }

     async render() {
        const rows = [];
        const pageHeight = this.box.height;
        const width = this.screen.width;

        // Add top marker if visible
        const showTopMarker = this.buffer.canSelectTopMarker() && this.buffer.topIndex === 0;
        if (showTopMarker) {
            rows.push({
                type: 'marker',
                marker: 'top',
                text: this.buildMarkerText('top', width)
            });
        }

        // Add file lines
        const availableHeight = pageHeight - (showTopMarker ? 1 : 0);
        const visibleLines = this.buffer.lines.slice(
            this.buffer.topIndex,
            this.buffer.topIndex + availableHeight
        );

        for (const line of visibleLines) {
            let text = line.text || '';
            if (this.scrollLeft < text.length) {
                text = text.substring(this.scrollLeft);
            } else {
                text = '';
            }
            
            // Ensure text fills the width to prevent bleeding
            text = (text + ' '.repeat(width)).substring(0, width);
            text = this.escapeForBlessed(text);
            rows.push({ type: 'line', text });
        }

        // Add bottom marker if at EOF
        if (this.buffer.canSelectBottomMarker() && rows.length < pageHeight) {
            rows.push({
                type: 'marker',
                marker: 'bottom',
                text: this.buildMarkerText('bottom', width)
            });
        }

        // Calculate which row should be highlighted
        let highlightRow = this.calculateHighlightRow();
        if (highlightRow >= 0 && highlightRow < rows.length) {
            rows[highlightRow].text = '{inverse}' + rows[highlightRow].text + '{/inverse}';
        }

        // Fill remaining space with empty lines
        while (rows.length < pageHeight) {
            rows.push({ type: 'empty', text: ' '.repeat(width) });
        }

        // Render to screen
        this.screen.realloc();
        this.box.setContent(rows.map(r => r.text).join('\n'));
        this.screen.render();
    }

    calculateHighlightRow() {
        if (this.buffer.highlightIndex === -1) {
            return this.buffer.canSelectTopMarker() && this.buffer.topIndex === 0 ? 0 : -1;
        }
        
        if (this.buffer.highlightIndex === this.buffer.lines.length) {
            const lastRow = this.box.height - 1;
            return this.buffer.canSelectBottomMarker() ? lastRow : -1;
        }

        if (this.buffer.highlightIndex < this.buffer.topIndex) {
            return -1;
        }

        const offset = (this.buffer.canSelectTopMarker() && this.buffer.topIndex === 0) ? 1 : 0;
        return offset + (this.buffer.highlightIndex - this.buffer.topIndex);
    }

    async moveHighlight(delta) {
        const { minIndex, maxIndex } = this.buffer.getHighlightBounds();
        const newIndex = this.buffer.highlightIndex + delta;
        
        // Clamp to valid range including markers
        this.buffer.highlightIndex = Math.max(minIndex, Math.min(newIndex, maxIndex));
        
        // If moving up at top, try to load more content
        if (delta < 0 && this.buffer.highlightIndex === 0 && this.buffer.topIndex === 0) {
            await this.buffer.fillBackward();
        }
        
        // If moving down near bottom, try to load more content
        if (delta > 0 && !this.buffer.fileReader.reachedEOF && 
            this.buffer.highlightIndex >= this.buffer.lines.length - this.box.height) {
            await this.buffer.fillForward();
        }

        // Ensure view follows highlight
        await this.adjustView();
        await this.render();
    }

    async adjustView() {
        const pageHeight = this.box.height;
        const markerOffset = this.buffer.canSelectTopMarker() && this.buffer.topIndex === 0 ? 1 : 0;
        
        // Handle top marker selection
        if (this.buffer.highlightIndex === -1) {
            this.buffer.topIndex = 0;
            return;
        }

        // Handle bottom marker selection
        if (this.buffer.highlightIndex === this.buffer.lines.length) {
            const visibleLines = pageHeight - (this.buffer.canSelectBottomMarker() ? 1 : 0);
            this.buffer.topIndex = Math.max(0, this.buffer.lines.length - visibleLines);
            return;
        }

        // Handle regular line selection
        if (this.buffer.highlightIndex < this.buffer.topIndex) {
            this.buffer.topIndex = this.buffer.highlightIndex;
        } else {
            const visibleLines = pageHeight - markerOffset - 
                  (this.buffer.canSelectBottomMarker() ? 1 : 0);
            if (this.buffer.highlightIndex >= this.buffer.topIndex + visibleLines) {
                this.buffer.topIndex = this.buffer.highlightIndex - visibleLines + 1;
            }
        }
    }
    
    scroll(delta) {
	this.scrollLeft = Math.max(0, this.scrollLeft + delta);
	this.render();
    }

    async jumpToTop() {
	this.buffer.lines = [];
	this.buffer.highlightIndex = -1; // Select top marker
	this.buffer.topIndex = 0;
	await this.buffer.fillForward(this.box.height);
	await this.render();
    }

    async jumpToBottom() {
	this.buffer.lines = [];
	this.buffer.topIndex = 0;
	await this.buffer.fillBackward(this.box.height * 2);
	this.buffer.highlightIndex = this.buffer.lines.length; // Select bottom marker
	await this.adjustView();
	await this.render();
    }
}

async function main() {
    if (process.argv.length < 3) {
        console.error('Usage: smore <filename>');
        process.exit(1);
    }

    try {
        // Create the file reader and open the file
        const fileReader = new FileReader(process.argv[2]);
        await fileReader.open();

        // Create the buffer manager
        const buffer = new BufferManager(fileReader);
        
        // Create the view (which creates the screen)
        const view = new View(buffer);
        
        // Initialize at the end of the file
        await buffer.fillBackward(view.box.height * 2);
        buffer.highlightIndex = buffer.lines.length; // Select bottom marker
        await view.adjustView();
        await view.render();

        // Set up file growth check
        setInterval(async () => {
            const stats = await fileReader.fileHandle.stat();
            if (stats.size !== fileReader.fileSize) {
                const wasAtBottom = buffer.highlightIndex === buffer.lines.length;
                fileReader.fileSize = stats.size;
                await buffer.fillForward();
                
                // If we were at bottom before, stay at bottom
                if (wasAtBottom) {
                    buffer.highlightIndex = buffer.lines.length;
                    await view.adjustView();
                }
                
                await view.render();
            }
        }, CONFIG.refreshInterval);

    } catch (err) {
        console.error('Error:', err);
        process.exit(1);
    }
}

main();
