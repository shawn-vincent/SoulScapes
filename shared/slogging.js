/**
 * slogging ‚Äì A Versatile, Thread‚ÄêSafe Logging Library
 *
 * Author: Shawn Vincent <svincent@svincent.com>
 *
 * Overview:
 *  slogging is a single‚Äêfile JavaScript logging library that supports multiple backends:
 *    ‚Ä¢ Console logging (browser console/stdout) with an independent log level (supports "none")
 *    ‚Ä¢ File logging with rollover (Node.js only), using size‚Äêbased rotation. When the log file
 *       exceeds a given size, it is renamed by appending a date‚Äêformatted string.
 *    ‚Ä¢ Socket logging (via HTTP POST) to a configured server endpoint with optional buffering.
 *
 *  It exports four main functions (which you can call directly):
 *    - sdebug(msg, ...objects)
 *    - slog(msg, ...objects)
 *    - swarn(msg, ...objects)
 *    - serror(msg, ...objects)
 *
 *  Additionally, you can log messages for a specific component by using:
 *    - csdebug(component, msg, ...objects)
 *    - cslog(component, msg, ...objects)
 *    - cswarn(component, msg, ...objects)
 *    - cerror(component, msg, ...objects)
 *
 *  By convention, all log messages should start with an emoji. For swarn()/cswarn() the
 *  default emoji is ‚ö†Ô∏è; for serror()/cerror() it is ‚ùå; for sdebug()/csdebug() it is üêõ (or
 *  ‚Äúüîß‚Äù for internal slogging messages); and for slog()/cslog() it is ‚ÑπÔ∏è (or ‚Äúüîß‚Äù for internal messages).
 *  (If the message already begins with an emoji, no additional one is added.)
 *
 *  Every log line is prefixed with a timestamp formatted like:
 *
 *     [Jan 1 '25 15:35:26.235 EST]
 *
 *  (Except that years outside 2000‚Äì2099 are printed in full.)
 *
 *  Log messages support a ${name} syntax. If the first parameter is an object (a substitution map)
 *  and the second parameter is a string, the string‚Äôs `${...}` tokens are replaced using that map.
 *
 *  Configuration options (via slogConfig) include:
 *
 *    1. Global log levels for file/socket output:
 *         logLevel: one of "debug", "log", "warn", "error", or "none" (default: "log")
 *         Additional keys with a ".{component}" suffix override the default for that component.
 *
 *    2. Console log level (independent of file/socket level). Defaults to the global log level if not specified:
 *         console: one of "debug", "log", "warn", "error", or "none"
 *         Additional keys with a ".{component}" suffix override the default for that component.
 *
 *    3. File Logging (Node.js only):
 *         logFile: {
 *           enabled: true,               // enable file logging
 *           path: "./slogger.log",       // destination file (default)
 *           maxSize: 1048576,            // maximum file size (in bytes) before rotation
 *           maxFiles: 5,                 // maximum number of rolled files to keep
 *           // The rolled file‚Äôs name is generated by appending a date string to the base file name.
 *           // If logFile.path ends with ".log", the default rolled name is:
 *           //    {base}-[yyyy-mm-dd-hh_mm_ss_SSS_TZ].log
 *           rollingPattern: null         // Optional custom pattern.
 *         }
 *
 *    4. Socket Logging:
 *         socketLogging: {
 *           enabled: true,
 *           endpoint: "http://yourserver.com/logs",
 *           bufferSize: 0              // number of messages to buffer before flushing (0 = no buffering)
 *         }
 *
 *    5. Unique Client Identifier:
 *         uniqueClientId: a function that accepts an object (e.g. an Express request)
 *         and returns a string. In the Express endpoint, the request object is passed.
 *         (Default: returns req.ip if available.)
 *
 * Usage Example (Client or Server):
 *  // Include the library (in Node.js: require("./slogging"); in browsers, include via a <script> tag)
 *  // The following functions become available globally:
 *  //   sdebug, slog, swarn, serror, csdebug, cslog, cswarn, cerror, slogConfig, slogExpressEndpoint
 *
 *  // Configure logging:
 *  slogConfig({
 *    logLevel: "log",       // for file/socket logging (or "none" to disable)
 *    "logLevel.specific": "debug", // (example override for component "specific")
 *    // console defaults to the global logLevel ("log") if not provided.
 *    logFile: {
 *      enabled: true,               // (Node.js only)
 *      path: "./slogger.log",
 *      maxSize: 1048576,            // 1 MB (for size-based rotation)
 *      maxFiles: 5
 *      // Optionally, you can specify a custom rollingPattern, e.g.:
 *      // rollingPattern: "slogger-[yyyy-mm-dd-hh_mm_ss_SSS_TZ].log"
 *    },
 *    socketLogging: {
 *      enabled: true,
 *      endpoint: "http://yourserver.com/logs",
 *      bufferSize: 5
 *    },
 *    uniqueClientId: function(req) {
 *      // Default: return the client‚Äôs IP address (if available).
 *      return req && req.ip ? req.ip : "unknown";
 *    }
 *  });
 *
 *  // Log some messages:
 *  sdebug({user: "alice"}, "User ${user} is debugging");
 *  slog("‚ÑπÔ∏è Application started");
 *  swarn("Potential issue detected");
 *  serror("An error occurred", new Error("oops"));
 *
 *  // Component-specific logging:
 *  csdebug("auth", {username: "bob"}, "Authentication attempt for ${username}");
 *
 *  // --- On the Server ---
 *  // In your Node.js Express server, you can create a log endpoint:
 *  const express = require("express");
 *  const app = express();
 *  app.use(express.json());
 *
 *  // This will create a POST endpoint at "/logs" that processes incoming log messages,
 *  // augmenting them with a unique client identifier (derived from the Express request).
 *  slogExpressEndpoint(app, "/logs");
 *
 *  // Start your Express server as usual.
 */

(function (global, factory) {
    // UMD wrapper: works in Node.js (CommonJS) and in browsers.
    if (typeof module !== "undefined" && module.exports) {
        var slogging = factory();
        // Expose functions directly on the global object in Node.js.
        global.sdebug = slogging.sdebug;
        global.slog = slogging.slog;
        global.swarn = slogging.swarn;
        global.serror = slogging.serror;
        global.csdebug = slogging.csdebug;
        global.cslog = slogging.cslog;
        global.cswarn = slogging.cswarn;
        global.cerror = slogging.cerror;
        global.slogConfig = slogging.slogConfig;
        global.slogExpressEndpoint = slogging.slogExpressEndpoint;
        module.exports = slogging;
    } else {
        var slogging = factory();
        // In browsers, attach to the global object.
        global.slogging = slogging;
        global.sdebug = slogging.sdebug;
        global.slog = slogging.slog;
        global.swarn = slogging.swarn;
        global.serror = slogging.serror;
        global.csdebug = slogging.csdebug;
        global.cslog = slogging.cslog;
        global.cswarn = slogging.cswarn;
        global.cerror = slogging.cerror;
        global.slogConfig = slogging.slogConfig;
        global.slogExpressEndpoint = slogging.slogExpressEndpoint;
    }
})(typeof global !== "undefined" ? global : this, function () {
    "use strict";

    // --- Log level definitions (lower number = more verbose) ---
    // Note: "none" disables logging for that destination.
    const LEVELS = {
        debug: 0,
        log: 1,
        warn: 2,
        error: 3,
        none: Infinity
    };

    // --- Global configuration (modifiable via slogConfig) ---
    // The logLevel and consoleLogLevel objects map component names to a numeric threshold.
    const config = {
        // Global (file/socket) log level: default is "log"
        logLevel: { default: LEVELS.log },
        // Console log level: defaults to the global level if not overridden.
        consoleLogLevel: { default: LEVELS.log },
        logFile: {
            enabled: false,             // File logging (Node.js only)
            path: "./slogger.log",       // Default logfile path
            maxSize: 1048576,           // Maximum file size (in bytes) before rotation
            maxFiles: 5,                // Maximum number of rolled logs to keep
            // For rolled logs, a custom pattern can be provided.
            // Default (if logFile.path ends with ".log"):
            //    {base}-[yyyy-mm-dd-hh_mm_ss_SSS_TZ].log
            rollingPattern: null
        },
        socketLogging: {
            enabled: false,
            endpoint: "",
            bufferSize: 0             // Number of messages to buffer before flushing (0 = no buffering)
        },
        // Default uniqueClientId function: expects an object (e.g. an Express request) and returns its IP.
        uniqueClientId: function (req) {
            return req && req.ip ? req.ip : "unknown";
        }
    };

    // --- Environment detection ---
    const isNode = (typeof process !== "undefined" &&
                    process.stdout &&
                    process.stderr);
    const isBrowser = !isNode;
    let fs, http, https, url, pathModule;
    if (isNode) {
        fs = require("fs");
        http = require("http");
        https = require("https");
        url = require("url");
        pathModule = require("path");
    }

    // --- Socket Logging Buffer and Guard ---
    let socketBuffer = [];
    // To prevent infinite recursion when socket logging errors occur.
    let skipSocketLogging = false;

    // --- Timestamp Formatting ---
    // Format: [Mon 1 '25 15:35:26.235 EST] for years 2000‚Äì2099; full year otherwise.
    function formatTimestamp(date) {
        const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
                        "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        const month = months[date.getMonth()];
        const day = date.getDate();
        const fullYear = date.getFullYear();
        let yearStr;
        if (fullYear >= 2000 && fullYear <= 2099) {
            yearStr = "'" + String(fullYear).slice(-2);
        } else {
            yearStr = fullYear;
        }
        const pad = (n, digits = 2) => String(n).padStart(digits, "0");
        const hours = pad(date.getHours());
        const minutes = pad(date.getMinutes());
        const seconds = pad(date.getSeconds());
        const ms = pad(date.getMilliseconds(), 3);
        const tz = getTimezoneAbbr(date);
        return `${month} ${day} ${yearStr} ${hours}:${minutes}:${seconds}.${ms} ${tz}`;
    }

    function getTimezoneAbbr(date) {
        const match = date.toTimeString().match(/\(([^)]+)\)$/);
        if (match && match[1]) {
            return match[1].split(" ").map(word => word[0]).join("");
        }
        return "";
    }

    // --- Helper: Stringify log arguments ---
    function stringify(arg) {
        if (typeof arg === "object") {
            try {
                return JSON.stringify(arg);
            } catch (e) {
                return String(arg);
            }
        }
        return String(arg);
    }

    // --- Helper: Check whether text starts with an emoji ---
    function startsWithEmoji(text) {
        return (/^\p{Extended_Pictographic}/u).test(text);
    }

    // --- Default Emoji based on level and component ---
    function getDefaultEmoji(level, component) {
        if (level === "debug") {
            return (component === "slogger") ? "üîß " : "üêõ ";
        } else if (level === "log") {
            return (component === "slogger") ? "üîß " : "‚ÑπÔ∏è ";
        } else if (level === "warn") {
            return "‚ö†Ô∏è ";
        } else if (level === "error") {
            return "‚ùå ";
        }
        return "";
    }

    // --- Substitution Support ---
    function performSubstitution(message, map) {
        return message.replace(/\$\{([^}]+)\}/g, function (match, key) {
            return Object.prototype.hasOwnProperty.call(map, key) ? map[key] : match;
        });
    }

    // Process log arguments for non-component functions.
    // If the first argument is a plain object and the second is a string,
    // use it as the substitution map.
    function processLogArgs(args) {
        let substitutionMap = null;
        let msg;
        let remaining;
        if (args.length >= 2 &&
            typeof args[0] === "object" && args[0] !== null &&
            !Array.isArray(args[0]) && !(args[0] instanceof Error) &&
            typeof args[1] === "string") {
            substitutionMap = args[0];
            msg = args[1];
            remaining = args.slice(2);
            msg = performSubstitution(msg, substitutionMap);
        } else {
            msg = args[0];
            remaining = args.slice(1);
        }
        return { msg, remaining };
    }

    // Process log arguments for component-specific functions.
    // The first parameter is the component.
    function processComponentLogArgs(component, args) {
        let substitutionMap = null;
        let msg;
        let remaining;
        if (args.length >= 2 &&
            typeof args[0] === "object" && args[0] !== null &&
            !Array.isArray(args[0]) && !(args[0] instanceof Error) &&
            typeof args[1] === "string") {
            substitutionMap = args[0];
            msg = args[1];
            remaining = args.slice(2);
            msg = performSubstitution(msg, substitutionMap);
        } else {
            msg = args[0];
            remaining = args.slice(1);
        }
        return { msg, remaining, component };
    }

    // --- File Logging Support (Node.js Only) ---
    // We support only size-based rotation. When the current log file exceeds maxSize,
    // we rename it by appending a date-formatted string.
    let currentFileSize = 0;

    // Initialize the current log file size.
    function initFileLogging() {
        if (isNode && config.logFile.enabled && config.logFile.path) {
            try {
                if (fs.existsSync(config.logFile.path)) {
                    currentFileSize = fs.statSync(config.logFile.path).size;
                } else {
                    currentFileSize = 0;
                }
            } catch (err) {
                cerror("slogger", "Error initializing log file", err);
            }
        }
    }

    // Rotate the log file when size exceeds maxSize.
    // The current log file is renamed to a new file with a date-augmented filename.
    // Then, old rolled files are purged if they exceed maxFiles.
    function rotateLogFileSizeBased() {
        const logPath = config.logFile.path;
        const now = new Date();
        let rolledFileName = "";
        if (config.logFile.rollingPattern && typeof config.logFile.rollingPattern === "string") {
            rolledFileName = config.logFile.rollingPattern
                .replace(/yyyy/g, now.getFullYear())
                .replace(/mm/g, String(now.getMonth() + 1).padStart(2, '0'))
                .replace(/dd/g, String(now.getDate()).padStart(2, '0'))
                .replace(/hh/g, String(now.getHours()).padStart(2, '0'))
                .replace(/MM/g, String(now.getMinutes()).padStart(2, '0'))
                .replace(/ss/g, String(now.getSeconds()).padStart(2, '0'))
                .replace(/SSS/g, String(now.getMilliseconds()).padStart(3, '0'))
                .replace(/TZ/g, getTimezoneAbbr(now));
        } else {
            // Default: if logPath ends with ".log", remove it.
            let base = logPath;
            if (logPath.toLowerCase().endsWith(".log")) {
                base = logPath.slice(0, -4);
            }
            rolledFileName = `${base}-[${getTimestampForFilename(now)}].log`;
        }
        try {
            if (fs.existsSync(logPath)) {
                fs.renameSync(logPath, rolledFileName);
            }
            currentFileSize = 0;
            // Enforce maxFiles: List rolled files matching the pattern and delete the oldest if needed.
            const dir = pathModule.dirname(logPath);
            const baseName = pathModule.basename(logPath, ".log");
            const pattern = new RegExp("^" + baseName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + "-\\[.*\\]\\.log$");
            const files = fs.readdirSync(dir).filter(f => pattern.test(f));
            if (files.length > config.logFile.maxFiles) {
                files.sort();
                const toDelete = files.slice(0, files.length - config.logFile.maxFiles);
                toDelete.forEach(file => {
                    try {
                        fs.unlinkSync(pathModule.join(dir, file));
                    } catch (e) {
                        cerror("slogger", "Error deleting old rolled file", file, e);
                    }
                });
            }
        } catch (err) {
            cerror("slogger", "Size-based file rotation error", err);
            throw err;
        }
    }

    // Returns a timestamp string for filenames in the format:
    // yyyy-mm-dd-hh_mm_ss_SSS_TZ (with underscore before timezone)
    function getTimestampForFilename(date) {
        const pad = (n, digits = 2) => String(n).padStart(digits, "0");
        const yyyy = date.getFullYear();
        const mm = pad(date.getMonth() + 1);
        const dd = pad(date.getDate());
        const hh = pad(date.getHours());
        const min = pad(date.getMinutes());
        const ss = pad(date.getSeconds());
        const SSS = pad(date.getMilliseconds(), 3);
        const tz = getTimezoneAbbr(date);
        return `${yyyy}-${mm}-${dd}-${hh}_${min}_${ss}_${SSS}_${tz}`;
    }

    function writeLogToFileSync(message) {
        try {
            if (!config.logFile.enabled) return;
            // Ensure the directory exists.
            const dir = pathModule.dirname(config.logFile.path);
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir, { recursive: true });
                // Log a warning to the console only (skip file logging) about the directory creation.
                logMessage("warn", "File logging directory created: " + dir, [], "slogger", { skipFile: true });
            }
            const messageSize = Buffer.byteLength(message + "\n", "utf8");
            if (currentFileSize + messageSize > config.logFile.maxSize) {
                rotateLogFileSizeBased();
            }
            fs.appendFileSync(config.logFile.path, message + "\n");
            currentFileSize += messageSize;
        } catch (err) {
            // When file logging fails, log the error only to the console (skip file logging) to avoid an infinite loop.
            logMessage("error", "File logging error: " + err.message, [], "slogger", { skipFile: true });
            // Optionally, you might throw the error here.
            // throw err;
        }
    }

    // --- Socket Logging Support ---
    function flushSocketBuffer() {
        if (socketBuffer.length === 0) return;
        const payload = JSON.stringify({ messages: socketBuffer });
        try {
            if (isNode) {
                const parsedUrl = url.parse(config.socketLogging.endpoint);
                const options = {
                    hostname: parsedUrl.hostname,
                    port: parsedUrl.port,
                    path: parsedUrl.path,
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Content-Length": Buffer.byteLength(payload)
                    }
                };
                const reqModule = parsedUrl.protocol === "https:" ? https : http;
                const req = reqModule.request(options, (res) => { res.on("data", () => {}); });
                req.on("error", (err) => {
                    if (!skipSocketLogging) {
                        skipSocketLogging = true;
                        serror("Socket logging error (flush): " + err.message);
                        skipSocketLogging = false;
                    }
                });
                req.write(payload);
                req.end();
            } else if (typeof fetch === "function") {
                fetch(config.socketLogging.endpoint, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: payload
                }).catch(err => {
                    if (!skipSocketLogging) {
                        skipSocketLogging = true;
                        serror("Socket logging error (flush): " + err.message);
                        skipSocketLogging = false;
                    }
                });
            } else {
                const xhr = new XMLHttpRequest();
                xhr.open("POST", config.socketLogging.endpoint, true);
                xhr.setRequestHeader("Content-Type", "application/json");
                xhr.send(payload);
            }
        } catch (err) {
            if (!skipSocketLogging) {
                skipSocketLogging = true;
                serror("Socket logging error (flush): " + err.message);
                skipSocketLogging = false;
            }
        }
        socketBuffer = [];
    }

    function sendLogToSocket(message) {
        if (!(config.socketLogging && config.socketLogging.enabled && config.socketLogging.endpoint)) {
            return;
        }
        if (config.socketLogging.bufferSize && config.socketLogging.bufferSize > 0) {
            socketBuffer.push(message);
            if (socketBuffer.length >= config.socketLogging.bufferSize) {
                flushSocketBuffer();
            }
        } else {
            const payload = JSON.stringify({ message: message });
            try {
                if (isNode) {
                    const parsedUrl = url.parse(config.socketLogging.endpoint);
                    const options = {
                        hostname: parsedUrl.hostname,
                        port: parsedUrl.port,
                        path: parsedUrl.path,
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Content-Length": Buffer.byteLength(payload)
                        }
                    };
                    const reqModule = parsedUrl.protocol === "https:" ? https : http;
                    const req = reqModule.request(options, (res) => { res.on("data", () => {}); });
                    req.on("error", (err) => {
                        if (!skipSocketLogging) {
                            skipSocketLogging = true;
                            serror("Socket logging error: " + err.message);
                            skipSocketLogging = false;
                        }
                    });
                    req.write(payload);
                    req.end();
                } else if (typeof fetch === "function") {
                    fetch(config.socketLogging.endpoint, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: payload
                    }).catch(err => {
                        if (!skipSocketLogging) {
                            skipSocketLogging = true;
                            serror("Socket logging error: " + err.message);
                            skipSocketLogging = false;
                        }
                    });
                } else {
                    const xhr = new XMLHttpRequest();
                    xhr.open("POST", config.socketLogging.endpoint, true);
                    xhr.setRequestHeader("Content-Type", "application/json");
                    xhr.send(payload);
                }
            } catch (err) {
                if (!skipSocketLogging) {
                    skipSocketLogging = true;
                    serror("Socket logging error: " + err.message);
                    skipSocketLogging = false;
                }
            }
        }
    }

    // --- Initialization of Slogger ---
    // Instead of logging immediately upon module load, delay logging the initialization message
    // until just before the first log message is sent.
    let _initialized = false;
    function ensureInitialized() {
        if (!_initialized) {
            _initialized = true;
            // Log the initialization message with five newlines prepended.
            // We skip file and socket logging so this message appears only in the console.
            logMessage("log", "üöÄ slogging library initialized", [], "slogger", { prependNewlines: 5, skipFile: true, skipSocket: true });
        }
    }

    // --- Core Logging Function ---
    // Accepts: level, msg, extraArgs (an array), an optional component (default: ""),
    // and an options object (currently supports skipFile and skipSocket, and prependNewlines).
    function logMessage(level, msg, extraArgs, component = "", opts = {}) {
        const now = new Date();
        const timestamp = formatTimestamp(now);
        // Prepend the default emoji if none is present.
        if (typeof msg === "string" && !startsWithEmoji(msg)) {
            msg = getDefaultEmoji(level, component) + msg;
        }
        // Format the line. If a component is specified, add it in brackets.
        let line = `[${timestamp}]` + (component ? ` [${component}] ` : " ") + msg;
        if (extraArgs && extraArgs.length > 0) {
            line += " " + extraArgs.map(stringify).join(" ");
        }
        // If requested, prepend newline characters before the log line.
        if (opts.prependNewlines) {
            line = "\n".repeat(opts.prependNewlines) + line;
        }
        // Determine effective log levels.
        const effectiveConsoleLevel =
              config.consoleLogLevel[component] !== undefined
              ? config.consoleLogLevel[component]
              : config.consoleLogLevel.default;
        const effectiveGlobalLevel =
              config.logLevel[component] !== undefined
              ? config.logLevel[component]
              : config.logLevel.default;
        // Console Logging: Wrap in try/catch.
        try {
            if (LEVELS[level] >= effectiveConsoleLevel) {
                if (isNode) {
                    if (level === "error") {
                        process.stderr.write(line + "\n");
                    } else {
                        process.stdout.write(line + "\n");
                    }
                } else {
                    if (level === "debug") {
                        console.debug(line);
                    } else if (level === "log") {
                        console.log(line);
                    } else if (level === "warn") {
                        console.warn(line);
                    } else if (level === "error") {
                        console.error(line);
                    }
                }
            }
        } catch (consoleErr) {
            if (isNode) {
                process.stderr.write("Console logging failed: " + consoleErr.message + "\n");
            } else {
                alert("Critical logging failure: " + consoleErr.message);
            }
        }
        // File Logging.
        if (!opts.skipFile && config.logFile.enabled && LEVELS[level] >= effectiveGlobalLevel) {
            if (!isNode) {
                serror("File logging is enabled but not supported in this environment.");
                throw new Error("File logging is enabled but not supported in this environment.");
            }
            writeLogToFileSync(line);
        }
        // Socket Logging.
        if (!opts.skipSocket && config.socketLogging.enabled && LEVELS[level] >= effectiveGlobalLevel) {
            sendLogToSocket(line);
        }
    }
    
    // --- Public API Functions for Non-Component Logging ---
    function sdebug(...args) {
        ensureInitialized();
        const { msg, remaining } = processLogArgs(args);
        let finalMsg = msg;
        if (typeof finalMsg === "string" && !/^\s*debug:/i.test(finalMsg)) {
            finalMsg = "debug: " + finalMsg;
        }
        logMessage("debug", finalMsg, remaining, "");
    }
    function slog(...args) {
        ensureInitialized();
        const { msg, remaining } = processLogArgs(args);
        logMessage("log", msg, remaining, "");
    }
    function swarn(...args) {
        ensureInitialized();
        const { msg, remaining } = processLogArgs(args);
        let finalMsg = msg;
        if (typeof finalMsg === "string" && !/^\s*warn:/i.test(finalMsg)) {
            finalMsg = "WARN: " + finalMsg;
        }
        logMessage("warn", finalMsg, remaining, "");
    }
    function serror(...args) {
        ensureInitialized();
        const { msg, remaining } = processLogArgs(args);
        let finalMsg = msg;
        if (typeof finalMsg === "string" && !/^\s*error:/i.test(finalMsg)) {
            finalMsg = "ERROR: " + finalMsg;
        }
        logMessage("error", finalMsg, remaining, "");
    }

    // --- Public API Functions for Component-Specific Logging ---
    function csdebug(component, ...args) {
        ensureInitialized();
        const { msg, remaining } = processComponentLogArgs(component, args);
        let finalMsg = msg;
        if (typeof finalMsg === "string" && !/^\s*debug:/i.test(finalMsg)) {
            finalMsg = "debug: " + finalMsg;
        }
        logMessage("debug", finalMsg, remaining, component);
    }
    function cslog(component, ...args) {
        ensureInitialized();
        const { msg, remaining } = processComponentLogArgs(component, args);
        logMessage("log", msg, remaining, component);
    }
    function cswarn(component, ...args) {
        ensureInitialized();
        const { msg, remaining } = processComponentLogArgs(component, args);
        let finalMsg = msg;
        if (typeof finalMsg === "string" && !/^\s*warn:/i.test(finalMsg)) {
            finalMsg = "WARN: " + finalMsg;
        }
        logMessage("warn", finalMsg, remaining, component);
    }
    function cerror(component, ...args) {
        ensureInitialized();
        const { msg, remaining } = processComponentLogArgs(component, args);
        let finalMsg = msg;
        if (typeof finalMsg === "string" && !/^\s*error:/i.test(finalMsg)) {
            finalMsg = "ERROR: " + finalMsg;
        }
        logMessage("error", finalMsg, remaining, component);
    }

    // --- Configuration Function ---
    // Accepts an options object with keys: logLevel, console, logFile, socketLogging, uniqueClientId.
    // Also supports keys with ".{component}" suffix to override per-component log levels.
    function slogConfig(options) {
        // Process global logLevel.
        if (options.logLevel !== undefined) {
            if (typeof options.logLevel === "string") {
                const lvl = options.logLevel.toLowerCase();
                if (lvl in LEVELS) {
                    config.logLevel.default = LEVELS[lvl];
                }
            } else if (typeof options.logLevel === "number") {
                config.logLevel.default = options.logLevel;
            }
        }
        // Process any per-component overrides in options (keys starting with "logLevel.")
        for (let key in options) {
            if (key.indexOf("logLevel.") === 0) {
                const comp = key.slice("logLevel.".length);
                const val = options[key];
                if (typeof val === "string") {
                    const lvl = val.toLowerCase();
                    if (lvl in LEVELS) {
                        config.logLevel[comp] = LEVELS[lvl];
                    }
                } else if (typeof val === "number") {
                    config.logLevel[comp] = val;
                }
            }
        }
        // Process console log level.
        if (options.console !== undefined) {
            if (typeof options.console === "string") {
                const lvl = options.console.toLowerCase();
                if (lvl in LEVELS) {
                    config.consoleLogLevel.default = LEVELS[lvl];
                }
            } else if (typeof options.console === "number") {
                config.consoleLogLevel.default = options.console;
            }
        }
        // Process per-component console overrides.
        for (let key in options) {
            if (key.indexOf("console.") === 0) {
                const comp = key.slice("console.".length);
                const val = options[key];
                if (typeof val === "string") {
                    const lvl = val.toLowerCase();
                    if (lvl in LEVELS) {
                        config.consoleLogLevel[comp] = LEVELS[lvl];
                    }
                } else if (typeof val === "number") {
                    config.consoleLogLevel[comp] = val;
                }
            }
        }
        if (options.logFile !== undefined) {
            config.logFile = Object.assign({}, config.logFile, options.logFile);
            if (config.logFile.enabled && !isNode) {
                serror("File logging is enabled but not supported in this environment.");
                throw new Error("File logging is enabled but not supported in this environment.");
            }
            if (config.logFile.enabled) {
                initFileLogging();
            }
        }
        if (options.socketLogging !== undefined) {
            config.socketLogging = Object.assign({}, config.socketLogging, options.socketLogging);
        }
        if (options.uniqueClientId !== undefined) {
            if (typeof options.uniqueClientId === "function") {
                config.uniqueClientId = options.uniqueClientId;
            }
        }
        // Log the new configuration using the internal "slogger" component (without prepended newlines).
        logMessage("log", "Slogging configuration set: " + JSON.stringify(config), [], "slogger");
    }

    // --- Express Endpoint Support ---
    // Call this on a Node.js Express server to create a POST endpoint that accepts log messages.
    // Incoming messages are augmented with a prefix of "[{uniqueClientId(req)}]" before logging.
    function slogExpressEndpoint(app, endpoint) {
        csdebug("slogger", "Creating Slogger express endpoint", { app: app, endpoint: endpoint });
        if (!app || typeof app.post !== "function") {
            throw new Error("Invalid Express app instance provided.");
        }
        app.post(endpoint, function (req, res) {
            const body = req.body;
            if (!body || !body.message) {
                res.status(400).send("Invalid log message payload.");
                return;
            }
            let clientId = "unknown";
            if (typeof config.uniqueClientId === "function") {
                try {
                    clientId = config.uniqueClientId(req);
                } catch (err) {
                    clientId = "unknown";
                }
            }
            const augmentedMessage = `[${clientId}] ${body.message}`;
            const level = body.level || "log";
            if (level === "debug") {
                sdebug(augmentedMessage);
            } else if (level === "warn") {
                swarn(augmentedMessage);
            } else if (level === "error") {
                serror(augmentedMessage);
            } else {
                slog(augmentedMessage);
            }
            res.status(200).send("Logged");
        });
    }

    // --- Delayed Initialization ---
    // The "slogger" initialization message (with five preceding newlines) is now delayed
    // until just before the first log message is sent.
    // (The ensureInitialized() function is called at the start of every public logging function.)
    
    // --- Exported API ---
    return {
        sdebug,
        slog,
        swarn,
        serror,
        csdebug,
        cslog,
        cswarn,
        cerror,
        slogConfig,
        slogExpressEndpoint
    };
});
